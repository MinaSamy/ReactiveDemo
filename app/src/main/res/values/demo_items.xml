<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="observable">Observable</string>
    <string name="observable_short_desc">An <b>Observable</b> emits items to subscribers in hot or cold fashion.
    Observables <b>subscribes</b> to observables to get notified when an observable emits an item</string>
    <string name="observable_desc">An <b>Observable</b> emits items to observers by calling <b>observer.onNext(T item)</b>.
    When all items are emitted, the observable can notify the observer by calling <b>observer.onCompleted()</b></string>

    <string name="observable_from">Observable.from()</string>
    <string name="observable_from_short_desc">An <b>Observable</b> emits items from an array/collection to subscribers. It emits items one
     by one saving us the need to iterate the array/collection</string>
    <string name="observable_from_desc">An <b>Observable</b> emits items to from a list, saving us the need to emit items
    one by one and calling <b>observer.onNext()</b> and <b>observer.onCompleted()</b> manually</string>

    <string name="observable_just">Observable.just()</string>
    <string name="observable_just_short_desc">An <b>Observable</b> emits items returned from a method. Here the method
    returns a list (not individual items as in the previous examples).</string>
    <string name="observable_just_desc">An <b>Observable</b> emits items returned from an existing method.
     For example it will emit a whole list returned from a method, it won\'t iterate the items in the list.
    We can <b>just</b> to have more organized and testable code</string>

    <string name="publish_subject">Publish Subject</string>
    <string name="publish_subject_short_desc">A <b>Subject</b> can as an observable and an observer in the same time.
    It can subscribe to an observable or to itself, thus acting as an observer in both cases</string>
    <string name="publish_subject_desc">A <b>Subject</b> can as an observable and an observer in the same time.
    It can subscribe to an observable or to itself, thus acting as an observer in both cases</string>

    <string name="behavior_subject">Behavior Subject</string>
    <string name="behavior_subject_short_desc">A <b>Subject</b> that emits the most recent item it has observed
        and all the subsequent items.</string>
    <string name="behavior_subject_desc">A <b>Subject</b> that emits the most recent item it has observed
        and all the subsequent items. All items emited before observation are lost.</string>

    <string name="replay_subject">Replay Subject</string>
    <string name="replay_subject_short_desc">A <b>Subject</b> that buffers all items that were produced before subscription
    and emits them to the observer once it subscribes</string>
    <string name="replay_subject_desc">A <b>Subject</b> that buffers all items that were produced before subscription
    and emits them to the observer once it subscribes</string>

    <string name="async_subject">Async Subject</string>
    <string name="async_subject_short_desc">A <b>Subject</b> that publishes only the last item the observable has emitted.</string>
    <string name="async_subject_desc">A <b>Subject</b> that publishes only the last item the observable has emitted.</string>

    <string name="repeat">Repeat</string>
    <string name="repeat_short_desc"><b>Observable.repeat()</b> repeats the items emitted by the observable.</string>
    <string name="repeat_desc"><b>Observable.repeat()</b> repeats the items emitted by the observable.</string>

    <string name="defer">Defer</string>
    <string name="defer_short_desc">An <b>Observable</b> that create other observable instances from a factory method.
        The observables creation is deferred until an <b>Observer</b>
     subscribes to it.</string>
    <string name="defer_desc">An <b>Observable</b> that calls a factory method to create another new observable instance
        for each new observer that subscribes to it, the observable creation is deferred until the <b>Observer</b>
     subscribes to it.</string>

    <string name="range">Range</string>
    <string name="range_short_desc">An <b>Observable</b> that emits items from a list, items are specified by the
    starting index and the number of items to emit.</string>
    <string name="range_desc">An <b>Observable</b> that emits items from a list, items are specified by the
    starting index and the number of items to emit.</string>

    <string name="interval">Interval</string>
    <string name="interval_short_desc">An <b>Observable</b> that emits items every n time unit. In this example the observable
     emits a new item every 3 seconds.</string>
    <string name="interval_desc">An <b>Observable</b> that emits items every n time unit. In this example the observable
     emits a new item every 3 seconds.</string>

    <string name="timer">Timer</string>
    <string name="timer_short_desc">An <b>Observable</b> that emits an item after n time unit. It can also act as <b>Interval</b>
    by emitting items after n time units each m time units.</string>
    <string name="timer_desc">An <b>Observable</b> that emits an item after n time unit. It can also act as <b>Interval</b>
    by emitting items after n time units each m time units.</string>

    <string name="filter">Filter</string>
    <string name="filter_short_desc">An <b>Observable</b> that emits items that pass a filter function, in this
     example we emit even number items only.</string>
    <string name="filter_desc">An <b>Observable</b> that emits items that pass a filter function, in this
     example we emit even number items only.</string>

    <string name="take">Take</string>
    <string name="take_short_desc">An <b>Observable</b> emits only the first N items from a sequence then completes</string>
    <string name="take_desc">An <b>Observable</b> emits only the first N items from a sequence then completes</string>

    <string name="take_last">Take Last</string>
    <string name="take_last_short_desc">An <b>Observable</b> that emits last N items from a sequence.
     In this example we emit the last two items from the list.</string>
    <string name="take_last_desc">An <b>Observable</b> that emits last N items from a sequence.
     In this example we emit the last two items from the list.</string>

    <string name="distinct">Distinct</string>
    <string name="distinct_short_desc">An <b>Observable</b> that emits unique items from a sequence, it gets
    rid of duplicate items</string>
    <string name="distinct_desc">An <b>Observable</b> that emits unique items from a sequence, it gets
    rid of duplicate items</string>

    <string name="distinct_until_changed">Distinct Until Changed</string>
    <string name="distinct_until_changed_short_desc">An <b>Observable</b> that emits unique items from a sequence, it notifies
    the observer when a new unique item - that\'s different than the previous items - is emitted</string>
    <string name="distinct_until_changed_desc">An <b>Observable</b> that emits unique items from a sequence, it notifies
    the observer when a new unique item - that\'s different than the previous items - is emitted</string>

    <string name="first">First</string>
    <string name="first_short_desc">An <b>Observable</b> that emits the first item from a sequence. The first item can be
    determined by a predicate function.</string>
    <string name="first_desc">An <b>Observable</b> that emits the first item from a sequence. The first item can be
    determined by a predicate function. There is another variant called <b>firstOrDefault()</b> that provides a default value if the observable doesn\'t
     emit an item that satisfies the predicate.</string>

    <string name="last">Last</string>
    <string name="last_short_desc">An <b>Observable</b> that emits the last item from a sequence. The last item can be
    determined by a predicate function.</string>
    <string name="last_desc">An <b>Observable</b> that emits the last item from a sequence. The last item can be
    determined by a predicate function. There is another variant called <b>lastOrDefault()</b> that provides a default value if the observable doesn\'t
     emit an item that satisfies the predicate.</string>

    <string name="skip">Skip</string>
    <string name="skip_short_desc">An <b>Observable</b> that skips the emitting the first N items.</string>
    <string name="skip_desc">An <b>Observable</b> that skips the emitting the first N items.</string>

    <string name="skip_last">Skip Last</string>
    <string name="skip_last_short_desc">An <b>Observable</b> that skips the emitting the last N items.</string>
    <string name="skip_last_desc">An <b>Observable</b> that skips the emitting the last N items.</string>

    <string name="sample">Sample</string>
    <string name="sample_short_desc">An <b>Observable</b> that emits the most recent emitted item from another observable
        in a certain periodic time interval</string>
    <string name="sample_desc">An <b>Observable</b> that emits the most recent emitted item from another observable
        in a certain periodic time interval. In this example an observable emits items every 3 seconds, another observable
    emits the last item emitted every 5 seconds</string>

    <string name="throttle_first">Throttle First</string>
    <string name="throttle_first_short_desc">An <b>Observable</b> that emits the first emitted item from another observable
        in a certain time window</string>
    <string name="throttle_first_desc">An <b>Observable</b> that emits the first emitted item from another observable
        in a certain time window. In this example an observable emits items every second, another observable
    emits the first item emitted within the 5 seconds window</string>

    <string name="throttle_last">Throttle Last</string>
    <string name="throttle_last_short_desc">An <b>Observable</b> that emits the last emitted item from another observable
        in a certain time window</string>
    <string name="throttle_last_desc">An <b>Observable</b> that emits the last emitted item from another observable
        in a certain time window. In this example an observable emits items every second, another observable
    emits the last item emitted within the 5 seconds window</string>

    <string name="map">Map</string>
    <string name="map_short_desc">Applies a specific <b>Func</b> object on each item emitted by the observable.</string>
    <string name="map_desc">Applies a specific <b>Func</b> object on each item emitted by the observable. In this
    example we apply a <b>Func</b> multiply each emitted item by 2.</string>

    <string name="flat_map">FlatMap</string>
    <string name="flat_map_short_desc">An <b>Observable</b> that takes the items emitted from one observable and emits the items of another one. It can
     convert the form of items emitted from an observable to another form.</string>
    <string name="flat_map_desc">An <b>Observable</b> that takes the items emitted from one observable and applies a function that returns an observable to each item emitted by the source observable and merge the results.
        A side effect of the flat map method is that it can interleave the items after applying the function to them, the original order of emitted items may not be maintained after the merge.
        In this example we have an observable that emits a list of strings, we apply
    a <b>FlatMap</b> operator that returns an <b>obsrvable.from()</b> object that enables subscribers to observe each item individually
     instead of observing the whole list as the first observable intended.</string>

    <string name="concat_map">ConcatMap</string>
    <string name="concat_map_short_desc">Similar to <b>flatMap</b>, except it concatenates the results after applying the function. thus the order of the emitted items
        from the source observable is maintained.</string>
    <string name="concat_map_desc">Similar to <b>flatMap</b>, it applies a function that returns an observable to each item emitted by a source observable,
        except it concatenates the results after applying the function. thus the order of the emitted items
        from the source observable is maintained.</string>

    <string name="flat_map_iterable">Flat Map Iterable</string>
    <string name="flat_map_iterable_short_desc">Similar to <b>flatMap</b>, it applies a function to each item emitted by the source observable, the function returns an iterable.</string>
    <string name="flat_map_iterable_desc">Similar to <b>flatMap</b>, it applies a function to each item emitted by the source observable, the function returns an iterable.</string>

    <string name="scan">Scan</string>
    <string name="scan_short_desc">Acts as an <b>accumulator</b>. it applies a function to each item emitted from the source observable,
        the function result is injected to the source observable to be used with the next emitted item.</string>
    <string name="scan_desc">Acts as an <b>accumulator</b>. it applies a function to each item emitted from the source observable,
        the function result is injected to the source observable to be used with the next emitted item. In this example
    we add each item emitted by the source observable to the next item emitted.</string>

    <string name="group_by">GroupBy</string>
    <string name="group_by_short_desc">groups the items emitted from a source observable and returns a new <b>GroupedObservable</b> with the grouped items</string>
    <string name="group_by_desc">groups the items emitted from a source observable and returns a new <b>GroupedObservable</b> with the grouped items.
     In this example we group the names list by the first letter of each name.</string>

    <string name="buffer">Buffer</string>
    <string name="buffer_short_desc">Transforms an observable that emits a single item to an observable that emits <b>count</b> items as a list.
     we can specify a <b>skip</b> value to skip emitting <b>n</b> items. Also we can specify a <b>timespan</b> to emit items every elapsed timespan.</string>
    <string name="buffer_desc">Transforms an observable that emits a single item to an observable that emits <b>count</b> items as a list.
     we can specify a <b>skip</b> value to skip emitting <b>n</b> items. Also we can specify a <b>timespan</b> so that the observable emits items the list every elapsed timespan.
     In this example the buffer emits a list of two items at once.</string>

    <string name="window">Window</string>
    <string name="window_short_desc">Similar to <b>Buffer</b> but it emits <b>Observables</b> instead of lists.
     We can also specify <b>skip</b> and <b>timespan</b> values</string>
    <string name="window_desc">Similar to <b>Buffer</b> but it emits <b>Observables</b> instead of lists.
     We can also specify <b>skip</b> and <b>timespan</b> values.
     In this example the window emits a observables with 2 items each.</string>

    <string name="cast">Cast</string>
    <string name="cast_short_desc">similar to <b>map</b> it transforms (casts) each item emitted from a source observable from its type to another type.</string>
    <string name="cast_desc">similar to <b>map</b> it transforms (casts) each item emitted from a source observable from its type to another type.
     In this example we transform each emitted Number item to an Integer</string>
    
    <string name="merge">Merge</string>
    <string name="merge_short_desc">An observable that combines two or more observables into a single observable.</string>
    <string name="merge_desc">An observable that combines two or more observables into a single observable. It\s useful when merging observables
     that emit items asynchronously, the merged onservable will maintain the order emission. If observables are merged synchronously, they will be concatenated.</string>

    <string name="zip">Zip</string>
    <string name="zip_short_desc">An observable that receives data emitted from two more observables, applies a <b>Func</b> on them and return a new observable.</string>
    <string name="zip_desc">An observable that receives data emitted from two more observables, applies a <b>Func</b> on them and return a new observable.</string>

    <string name="join">Join</string>
    <string name="join_short_desc">combines items from two whenever an item from one observable is emitted during a time window specified by an item emitted from the other observable.</string>
    <string name="join_desc">combines items from two observables working with time windows.</string>

</resources>